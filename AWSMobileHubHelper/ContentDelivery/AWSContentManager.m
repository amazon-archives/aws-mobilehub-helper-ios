//
//  AWSContentManager.m
//
// Copyright 2016 Amazon.com, Inc. or its affiliates (Amazon). All Rights Reserved.
//
// Code generated by AWS Mobile Hub. Amazon gives unlimited permission to
// copy, distribute and modify it.
//
#import "AWSContentManager.h"

#import <AWSS3/AWSS3.h>

#import <CommonCrypto/CommonCryptor.h>
#import <CommonCrypto/CommonDigest.h>

NSString *const AWSContentManagerErrorDomain = @"com.amazonaws.AWSContentManager.ErrorDomain";

NSString *const AWSContentManagerContentCacheName = @"com.amazonaws.%@.ContentCacheName";
NSString *const AWSContentManagerPinnedCacheName = @"com.amazonaws.%@.PinnedCacheName";

NSUInteger const AWSContentManagerDefaultByteLimit = 20 * 1024  * 1024; // 20 MB

NSString *const AWSContentManagerUserDefaultsByteLimitKey = @"com.amazonaws.AWSContentManager.ByteLimit";

NSUInteger const AWSContentManagerMaxKeys = 100;

@protocol AWSContentProvider <NSObject>

@required

- (void)GETURLForKey:(NSString *)key
   completionHandler:(void(^)(NSURL *URL, NSError *error))completionHandler;

- (void)PUTURLForKey:(NSString *)key
   completionHandler:(void(^)(NSURL *URL, NSError *error))completionHandler;

- (void)DELETEURLForKey:(NSString *)key
      completionHandler:(void (^)(NSURL *, NSError *))completionHandler;

@end

@interface AWSContentManager() <NSURLSessionDelegate>

@property (nonatomic, strong) NSMutableDictionary *contents;
@property (nonatomic, strong) AWSTMCache *contentCache;
@property (nonatomic, strong) AWSTMCache *pinnedCache;
@property (nonatomic, strong) id<AWSContentProvider> contentProvider;
@property (nonatomic, strong) NSURLSession *URLSession;
@property (nonatomic, strong) NSMutableDictionary *runningTasks;

@property (nonatomic, strong) NSMutableArray *uploadingContents;

@property (nonatomic, strong) NSString *bucket;
@property (nonatomic, strong) AWSServiceConfiguration *serviceConfiguration;
@property (nonatomic, strong) AWSS3 *s3;

@end

@interface AWSLocalContent : AWSContent

- (void)uploadWithPinOnCompletion:(BOOL)pinOnCompletion
                    progressBlock:(void(^)(AWSLocalContent *content, NSProgress *progress))progressBlock
                completionHandler:(void(^)(AWSLocalContent *content, NSError *error))completionHandler;

@end

@interface AWSContent()

@property (nonatomic, strong) AWSContentManager *manager;

@property (nonatomic, assign, getter=isDirectory) BOOL directory;
@property (nonatomic, assign) AWSContentStatusType status;
@property (nonatomic, strong) NSProgress *progress;
@property (nonatomic, strong) NSString *key;
@property (nonatomic, strong) NSDate *knownRemoteLastModifiedDate;
@property (nonatomic, assign) NSUInteger knownRemoteByteCount;

@property (nonatomic, strong) NSData *temporaryData;
@property (nonatomic, copy) void(^downloadProgressBlock)(AWSContent *content, NSProgress *progress);
@property (nonatomic, copy) void(^downloadCompletionHandler)(AWSContent *content, NSData *data, NSError *error);
@property (nonatomic, assign) BOOL pinOnCompletion;

@property (nonatomic, strong) NSData *uploadData;
@property (nonatomic, copy) void(^uploadProgressBlock)(AWSLocalContent *content, NSProgress *progress);
@property (nonatomic, copy) void(^uploadCompletionHandler)(AWSLocalContent *content, NSError *error);

- (instancetype)initWithManager:(AWSContentManager *)manager;

- (void)setUserAgentForRequest:(NSMutableURLRequest *)request;

@end

@interface AWSS3ContentProvider : NSObject <AWSContentProvider>

@property (readonly) NSString *bucket;
@property (readonly) AWSServiceConfiguration *serviceConfiguration;
@property (readonly) AWSS3PreSignedURLBuilder *awsS3PresignedURLBuilder;

- (instancetype)initWithBucket:(NSString *)bucket;

- (instancetype)initWithBucket:(NSString *)bucket
          serviceConfiguration:(AWSServiceConfiguration *)serviceConfiguration;

@end

@interface AWSCloudFrontContentProvider : NSObject <AWSContentProvider>

@property (readonly) NSString *cloudFrontURL;

- (instancetype)initWithCloudFrontURL:(NSString *)cloudFrontURL;

@end

@interface NSURL (AWS)

- (id)aws_getResourceValue:(NSString *)key;

@end

@interface NSData (AWS)

- (NSString *)aws_md5String;

@end

@interface AWSTMDiskCache (AWS)

- (NSURL *)aws_fileURLWithoutUpdatingLastAccessedDateForKey:(NSString *)key;
- (void)aws_fileURLWithoutUpdatingLastAccessedDateForKey:(NSString *)key block:(AWSTMDiskCacheObjectBlock)block;

@end

@interface AWSS3()

- (instancetype)initWithConfiguration:(AWSServiceConfiguration *)configuration;

@end

#pragma mark - AWSContentManager

typedef NS_ENUM(NSInteger, AWSContentManagerType){
    AWSContentManagerTypeS3,
    AWSContentManagerTypeCloudFront,
};

@implementation AWSContentManager

static NSString *const AWSInfoContentManager = @"ContentManager";
static NSString *const AWSContentManagerBucketName = @"S3Bucket";
static NSString *const AWSContentManagerCloudFrontURL = @"CloudFrontURL";
static AWSSynchronizedMutableDictionary *_serviceClients = nil;

#pragma mark - Initializers

+ (instancetype)defaultContentManager {
    static AWSContentManager *_defaultContentManager = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        AWSServiceConfiguration *serviceConfiguration = nil;
        AWSServiceInfo *serviceInfo = [[AWSInfo defaultAWSInfo] defaultServiceInfo:AWSInfoContentManager];
        if (serviceInfo) {
            serviceConfiguration = [[AWSServiceConfiguration alloc] initWithRegion:serviceInfo.region
                                                               credentialsProvider:serviceInfo.cognitoCredentialsProvider];
        }

        if (!serviceConfiguration) {
            serviceConfiguration = [AWSServiceManager defaultServiceManager].defaultServiceConfiguration;
        }

        if (!serviceConfiguration) {
            @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                           reason:@"The service configuration is `nil`. You need to configure `Info.plist` or set `defaultServiceConfiguration` before using this method."
                                         userInfo:nil];
        }

        NSString *bucketName = [serviceInfo.infoDictionary objectForKey:AWSContentManagerBucketName];
        NSString *cloudFrontURL = [serviceInfo.infoDictionary objectForKey:AWSContentManagerCloudFrontURL];

        if (bucketName && cloudFrontURL) {
            _defaultContentManager = [[AWSContentManager alloc] initWithType:AWSContentManagerTypeCloudFront
                                                                      bucket:bucketName
                                                               cloudFrontURL:cloudFrontURL
                                                        serviceConfiguration:serviceConfiguration
                                                                  identifier:AWSInfoDefault];
        } else if (bucketName) {
            _defaultContentManager = [[AWSContentManager alloc] initWithType:AWSContentManagerTypeS3
                                                                      bucket:bucketName
                                                               cloudFrontURL:nil
                                                        serviceConfiguration:serviceConfiguration
                                                                  identifier:AWSInfoDefault];
        } else {
            @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                           reason:@"The Content Manager specific configuration is set incorrectly in the `Info.plist` file. You need to configure `Info.plist` before using this method."
                                         userInfo:nil];
        }
    });
    
    return _defaultContentManager;
}

+ (void)registerContentManagerWithConfiguration:(AWSContentManagerConfiguration *)contentManagerConfiguration
                                         forKey:(NSString *)key {
    if ([key isEqualToString:AWSInfoDefault]) {
        @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                       reason:@"The key used for registering this instance is a reserved key. Please use some other key to register the instance."
                                     userInfo:nil];
    }
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _serviceClients = [AWSSynchronizedMutableDictionary new];
    });
    if(contentManagerConfiguration.cloudFrontURL != nil) {
        [_serviceClients setObject:[[AWSContentManager alloc] initWithType:AWSContentManagerTypeCloudFront
                                                                    bucket:contentManagerConfiguration.bucketName
                                                             cloudFrontURL:contentManagerConfiguration.cloudFrontURL
                                                      serviceConfiguration:contentManagerConfiguration.serviceConfiguration
                                                                identifier:key]
                            forKey:key];
    }
    else {
        [_serviceClients setObject: [[AWSContentManager alloc] initWithType:AWSContentManagerTypeS3
                                                                     bucket:contentManagerConfiguration.bucketName
                                                              cloudFrontURL:nil
                                                       serviceConfiguration:contentManagerConfiguration.serviceConfiguration
                                                                 identifier:key]
                            forKey:key];
    }
}

+ (instancetype)ContentManagerForKey:(NSString *)key {
    @synchronized(self) {
        AWSContentManager *serviceClient = [_serviceClients objectForKey:key];
        if (serviceClient) {
            return serviceClient;
        }
        
        AWSServiceInfo *serviceInfo = [[AWSInfo defaultAWSInfo] serviceInfo:AWSInfoContentManager
                                                                     forKey:key];
        if (serviceInfo) {
            AWSServiceConfiguration *serviceConfiguration = [[AWSServiceConfiguration alloc] initWithRegion:serviceInfo.region
                                                                                        credentialsProvider:serviceInfo.cognitoCredentialsProvider];
            NSString *bucketName = [serviceInfo.infoDictionary objectForKey:AWSContentManagerBucketName];
            NSString *cloudFrontURL = [serviceInfo.infoDictionary objectForKey:AWSContentManagerCloudFrontURL];
            
            AWSContentManagerConfiguration *contentManagerConfiguration = [[AWSContentManagerConfiguration alloc]initWithBucketName:bucketName cloudFrontURL:cloudFrontURL serviceConfiguration:serviceConfiguration];
            
            if (bucketName) {
                [AWSContentManager registerContentManagerWithConfiguration:contentManagerConfiguration
                                                                    forKey:key];
            } else {
                @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                               reason:@"The Content Manager specific configuration is set incorrectly in the `Info.plist` file. You need to configure `Info.plist` before using this method."
                                             userInfo:nil];
            }
        }
        
        return [_serviceClients objectForKey:key];
    }
}

+ (void)removeContentManagerForKey:(NSString *)key {
    [_serviceClients removeObjectForKey:key];
}

- (instancetype)initWithType:(AWSContentManagerType)type
                      bucket:(NSString *)bucket
               cloudFrontURL:(NSString *)cloudFrontURL
        serviceConfiguration:(AWSServiceConfiguration *)serviceConfiguration
                  identifier:(NSString *)identifier {
    if (self = [super init]) {
        _contents = [NSMutableDictionary new];
        _runningTasks = [NSMutableDictionary new];
        _uploadingContents = [NSMutableArray new];
        
        // Gets Application Support directory.
        NSFileManager *fileManager = [NSFileManager defaultManager];
        NSArray *URLs = [fileManager URLsForDirectory:NSApplicationSupportDirectory
                                            inDomains:NSUserDomainMask];
        NSURL *URL = nil;
        if ([URLs count] > 0) {
            URL = URLs[0];
            _contentCache = [[AWSTMCache alloc] initWithName:[NSString stringWithFormat:@"%@-%@", [NSString stringWithFormat:AWSContentManagerContentCacheName, NSStringFromClass([self class])], identifier]
                                                    rootPath:URL.path];
            _pinnedCache = [[AWSTMCache alloc] initWithName:[NSString stringWithFormat:@"%@-%@", [NSString stringWithFormat:AWSContentManagerPinnedCacheName, NSStringFromClass([self class])], identifier]
                                                   rootPath:URL.path];
            
            _contentCache.diskCache.byteLimit = self.maxCacheSize;
            
            if (type == AWSContentManagerTypeS3) {
                _contentProvider = [[AWSS3ContentProvider alloc] initWithBucket:bucket
                                                           serviceConfiguration:serviceConfiguration];
            } else if (type == AWSContentManagerTypeCloudFront) {
                _contentProvider = [[AWSCloudFrontContentProvider alloc] initWithCloudFrontURL:cloudFrontURL];
            } else {
                assert(false);
            }
            
            _s3 = [[AWSS3 alloc] initWithConfiguration:serviceConfiguration];
            
            _bucket = bucket;
            _serviceConfiguration = serviceConfiguration;
            
            NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
            _URLSession = [NSURLSession sessionWithConfiguration:configuration
                                                        delegate:self
                                                   delegateQueue:[NSOperationQueue mainQueue]];
        } else {
            AWSLogError(@"Failed to retrieve the Application Support directory.");
        }
    }
    return self;
}

#pragma mark - Properties

- (NSUInteger)maxCacheSize {
    
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    NSNumber *byteLimit = [userDefaults objectForKey:AWSContentManagerUserDefaultsByteLimitKey];
    if (!byteLimit) {
        return AWSContentManagerDefaultByteLimit;
    }
    return [byteLimit unsignedIntegerValue];
}

- (void)setMaxCacheSize:(NSUInteger)byteLimit {
    
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    [userDefaults setObject:@(byteLimit)
                     forKey:AWSContentManagerUserDefaultsByteLimitKey];
    self.contentCache.diskCache.byteLimit = byteLimit;
}

- (NSUInteger)cachedUsedSize {
    return self.contentCache.diskByteCount;
}

- (NSUInteger)pinnedSize {
    return self.pinnedCache.diskByteCount;
}

#pragma mark - User action methods

- (void)listAvailableContentsWithPrefix:(NSString * _Nullable)prefix
                                 marker:(NSString * _Nullable)marker
                      completionHandler:(void (^)(NSArray<AWSContent *>  * _Nullable contents, NSString  * _Nullable marker, NSError  * _Nullable error))completionHandler {
    
    AWSS3 *s3 = self.s3;
    AWSS3ListObjectsRequest *listObjectsRequest = [AWSS3ListObjectsRequest new];
    listObjectsRequest.bucket = self.bucket;
    listObjectsRequest.maxKeys = @(AWSContentManagerMaxKeys);
    listObjectsRequest.marker = marker;
    listObjectsRequest.delimiter = @"/";
    if (prefix) {
        listObjectsRequest.prefix = prefix;
    }
    
    __weak AWSContentManager *weakSelf = self;
    [[s3 listObjects:listObjectsRequest] continueWithBlock:^id(AWSTask *task) {
        dispatch_async(dispatch_get_main_queue(), ^{
            if (task.error) {
                completionHandler(nil, nil, task.error);
            }
            if (task.result) {
                AWSS3ListObjectsOutput *listObjectsOutput = task.result;
                
                NSMutableDictionary *activeKeys = [NSMutableDictionary new];
                
                for (AWSS3Object *object in listObjectsOutput.contents) {
                    AWSContent *content = [weakSelf contentForKey:object.key];
                    
                    content.knownRemoteLastModifiedDate = object.lastModified;
                    content.knownRemoteByteCount = [object.size integerValue];
                    
                    [activeKeys setObject:object.key forKey:object.key];
                }
                
                if (!marker) {
                    for (NSString *key in [weakSelf.contents allKeys]) {
                        if (![activeKeys objectForKey:key]) {
                            [weakSelf.contents removeObjectForKey:key];
                        }
                    }
                }
                
                for (AWSS3CommonPrefix *commonPrefix in listObjectsOutput.commonPrefixes) {
                    AWSContent *content = [weakSelf contentForKey:commonPrefix.prefix];
                    content.directory = YES;
                    
                    [activeKeys setObject:commonPrefix.prefix forKey:commonPrefix.prefix];
                }
                
                [weakSelf.contentCache.diskCache enumerateObjectsWithBlock:^(AWSTMDiskCache *cache,
                                                                             NSString *key,
                                                                             id<NSCoding> object,
                                                                             NSURL *fileURL) {
                    [weakSelf contentForKey:key];
                }];
                [weakSelf.pinnedCache.diskCache enumerateObjectsWithBlock:^(AWSTMDiskCache *cache,
                                                                            NSString *key,
                                                                            id<NSCoding> object,
                                                                            NSURL *fileURL) {
                    [weakSelf contentForKey:key];
                }];
                
                NSArray *contents = [weakSelf filteredContentsWithPrefix:prefix];
                NSString *nextMarker = listObjectsOutput.nextMarker;
                completionHandler(contents, nextMarker, nil);
            }
        });
        return nil;
    }];
}

- (void)listRecentContentsWithPrefix:(NSString * _Nullable)prefix
                   completionHandler:(void (^)(NSArray<AWSContent *> *result, NSError *error))completionHandler {
    __block NSMutableArray *recentContents = [NSMutableArray new];
    [[self listRecentContents:recentContents
                   nextMarker:nil
                       prefix:prefix
                      counter:10] continueWithBlock:^id _Nullable(AWSTask * _Nonnull task) {
        
        if (task.error) {
            completionHandler(nil, task.error);
            return nil;
        }
        
        NSArray *sortedContents = [recentContents sortedArrayUsingComparator:^NSComparisonResult(AWSS3Object * _Nonnull obj1, AWSS3Object * _Nonnull obj2) {
            return [obj2.lastModified compare:obj1.lastModified];
        }];
        recentContents = nil;
        
        NSMutableArray *resultArray = [NSMutableArray new];
        
        NSUInteger availableCacheByteCount = self.maxCacheSize - self.cachedUsedSize;
        for (AWSS3Object *object in sortedContents) {
            NSUInteger size = [object.size unsignedIntegerValue];
            if (size > 0
                && ![self.contentCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:object.key]
                && ![self.pinnedCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:object.key]
                && size + 4 * 1024 < availableCacheByteCount) {
                availableCacheByteCount -= size + 4 * 1024;
                
                AWSContent *content = [self contentForKey:object.key];
                [resultArray addObject:content];
            }
        }
        completionHandler(resultArray, nil);
        return nil;
    }];
}

- (AWSTask *)listRecentContents:(NSMutableArray *)recentContents
                     nextMarker:(NSString *)nextMarker
                         prefix:(NSString *)prefix
                        counter:(int32_t)counter {
    AWSS3 *s3 = self.s3;
    AWSS3ListObjectsRequest *listObjectsRequest = [AWSS3ListObjectsRequest new];
    listObjectsRequest.bucket = self.bucket;
    listObjectsRequest.marker = nextMarker;
    listObjectsRequest.prefix = prefix;
    
    return [[s3 listObjects:listObjectsRequest] continueWithSuccessBlock:^id(AWSTask *task) {
        if ([task.result isKindOfClass:[AWSS3ListObjectsOutput class]]) {
            AWSS3ListObjectsOutput *listObjectsOutput = task.result;
            [recentContents addObjectsFromArray:listObjectsOutput.contents];
            
            if (counter > 0 && [listObjectsOutput.isTruncated boolValue]) {
                NSString *nextMarker = listObjectsOutput.nextMarker;
                if (!nextMarker) {
                    AWSS3Object *lastObject = [listObjectsOutput.contents lastObject];
                    nextMarker = lastObject.key;
                }
                return [self listRecentContents:recentContents
                                     nextMarker:nextMarker
                                         prefix:prefix
                                        counter:counter - 1];
            }
        }
        return nil;
    }];
}

- (NSArray *)filteredContentsWithPrefix:(NSString *)prefix {
    NSString *currentDirectory = nil;
    NSArray *sortedContents = [[self.contents allValues] sortedArrayUsingComparator:^NSComparisonResult(AWSContent *obj1, AWSContent *obj2) {
        return [obj1.key compare:obj2.key];
    }];
    NSMutableArray *contents = [NSMutableArray new];
    for (AWSContent *content in sortedContents) {
        if ((!prefix || [content.key hasPrefix:prefix]) && ![content.key isEqualToString:prefix]) {
            if (currentDirectory && [content.key hasPrefix:currentDirectory]) {
                continue;
            }
            
            [contents addObject:content];
            
            if (content.isDirectory) {
                currentDirectory = content.key;
            }
        }
    }
    
    return contents;
}

- (AWSContent *)contentForKey:(NSString *)key {
    AWSContent *content = [self.contents objectForKey:key];
    if (!content) {
        content = [[AWSContent alloc] initWithManager:self];
        content.key = key;
        [self.contents setValue:content
                         forKey:content.key];
    }
    return content;
}

- (void)clearCache {
    [self.contents removeAllObjects];
    [self.contentCache removeAllObjects];
    [self.pinnedCache removeAllObjects];
}

- (AWSContent *)contentWithKey:(NSString *)key {
    AWSContent *content = [self contentForKey:key];
    return content;
}

#pragma mark - NSURLSessionTaskDelegate

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
didCompleteWithError:(NSError *)error {
    if ([task isKindOfClass:[NSURLSessionDownloadTask class]]) {
        AWSContent *content = self.runningTasks[@(task.taskIdentifier)];
        NSData *data = nil;
        
        if (!error) {
            NSHTTPURLResponse *HTTPResponse = (NSHTTPURLResponse *)task.response;
            if (HTTPResponse.statusCode / 100 == 4) {
                error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                            code:AWSContentManagerErrorTypeClientException
                                        userInfo:nil];
                AWSLogError(@"Transfer failed. HTTP Status Code: %lld", (long long)HTTPResponse.statusCode);
                data = content.temporaryData;
            } else if (HTTPResponse.statusCode / 100 == 5) {
                error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                            code:AWSContentManagerErrorTypeServiceException
                                        userInfo:nil];
                AWSLogError(@"Transfer failed. HTTP Status Code: %lld", (long long)HTTPResponse.statusCode);
                data = content.temporaryData;
            } else  if (HTTPResponse.statusCode == 304) { // Not Modified
                data = content.cachedData;
                if (content.pinOnCompletion) {
                    if([self.contentCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:content.key]) {
                        [content pin];
                    }
                }
            } else {
                data = content.temporaryData;
                if (content.pinOnCompletion) {
                    [self.pinnedCache.diskCache setObject:data
                                                   forKey:content.key];
                } else {
                    [self.contentCache.diskCache setObject:data
                                                    forKey:content.key];
                }
            }
        }
        
        content.downloadCompletionHandler(content, data, error);
        
        content.temporaryData = nil;
        content.downloadCompletionHandler = nil;
        content.downloadProgressBlock = nil;
        
        content.status = AWSContentStatusTypeCompleted;
    } else if ([task isKindOfClass:[NSURLSessionDataTask class]]) {
        AWSLocalContent *content = self.runningTasks[@(task.taskIdentifier)];
        
        [self.uploadingContents removeObject:content];
        
        if (content.pinOnCompletion) {
            [self.pinnedCache.diskCache setObject:content.uploadData
                                           forKey:content.key];
        }
        
        content.uploadCompletionHandler(content, error);
        
        content.uploadData = nil;
        content.uploadCompletionHandler = nil;
        content.uploadProgressBlock = nil;
    }
    
    [self.runningTasks removeObjectForKey:@(task.taskIdentifier)];
}

- (void)URLSession:(NSURLSession *)session
              task:(NSURLSessionTask *)task
   didSendBodyData:(int64_t)bytesSent
    totalBytesSent:(int64_t)totalBytesSent
totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {
    id content = self.runningTasks[@(task.taskIdentifier)];
    
    if ([content isKindOfClass:[AWSLocalContent class]]) {
        AWSLocalContent *localContent = content;
        localContent.progress.completedUnitCount = totalBytesSent;
        localContent.progress.totalUnitCount = totalBytesExpectedToSend;
        localContent.uploadProgressBlock(localContent, localContent.progress);
    }
}

#pragma mark - NSURLSessionDownloadDelegate

- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location {
    
    AWSContent *content = self.runningTasks[@(downloadTask.taskIdentifier)];
    content.temporaryData = [NSData dataWithContentsOfURL:location];
}

- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten
 totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {
    
    AWSContent *content = self.runningTasks[@(downloadTask.taskIdentifier)];
    content.progress.completedUnitCount = totalBytesWritten;
    content.progress.totalUnitCount = totalBytesExpectedToWrite;
    content.downloadProgressBlock(content, content.progress);
}

@end

#pragma mark - AWSContent

@implementation AWSContent

- (instancetype)init {
    assert(false);
}

- (instancetype)initWithManager:(AWSContentManager *)manager {
    if (self = [super init]) {
        _manager = manager;
        _directory = NO;
        _status = AWSContentStatusTypeNotStarted;
    }
    return self;
}

#pragma mark - Properties

- (BOOL)isCached {
    AWSTMCache *contentCache = self.manager.contentCache;
    AWSTMCache *pinnedCache = self.manager.pinnedCache;
    return [contentCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key]
    || [pinnedCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key];
}

- (BOOL)isPinned {
    AWSTMCache *pinnedCache = self.manager.pinnedCache;
    return [pinnedCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key] != nil;
}

- (NSDate *)downloadedDate {
    AWSTMCache *contentCache = self.manager.contentCache;
    NSURL *fileURL = [contentCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key];
    NSDate *downloadDate = [fileURL aws_getResourceValue:NSURLCreationDateKey];
    
    if (!downloadDate) {
        AWSTMCache *pinnedCache = self.manager.pinnedCache;
        fileURL = [pinnedCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key];
        downloadDate = [fileURL aws_getResourceValue:NSURLCreationDateKey];
    }
    
    return downloadDate;
}

- (NSUInteger)fileSize {
    AWSTMCache *contentCache = self.manager.contentCache;
    NSURL *fileURL = [contentCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key];
    NSNumber *totalFileAllocatedSize = [fileURL aws_getResourceValue:NSURLTotalFileAllocatedSizeKey];
    
    if (!totalFileAllocatedSize) {
        AWSTMCache *pinnedCache = self.manager.pinnedCache;
        fileURL = [pinnedCache.diskCache aws_fileURLWithoutUpdatingLastAccessedDateForKey:self.key];
        totalFileAllocatedSize = [fileURL aws_getResourceValue:NSURLTotalFileAllocatedSizeKey];
    }
    
    return [totalFileAllocatedSize unsignedIntegerValue];
}

- (NSProgress *)progress {
    if (!_progress) {
        _progress = [NSProgress new];
    }
    return _progress;
}

#pragma mark - User action methods

- (void)downloadWithDownloadType:(AWSContentDownloadType)loadingType
                 pinOnCompletion:(BOOL)pinOnCompletion
                   progressBlock:(void(^)(AWSContent *content, NSProgress *progress))progressBlock
               completionHandler:(void(^)(AWSContent *content, NSData *data, NSError *error))completionHandler {
    if (self.isDirectory) {
        NSError *error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                             code:AWSContentManagerErrorTypeDirectoryCannotBeDownloaded
                                         userInfo:nil];
        completionHandler(self, nil, error);
        return;
    }
    if (self.status == AWSContentStatusTypeRunning) {
        NSError *error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                             code:AWSContentManagerErrorTypeTransferAlreadyInProgress
                                         userInfo:nil];
        completionHandler(self, nil, error);
        return;
    }
    
    if (loadingType == AWSContentDownloadTypeIfNotCached) {
        NSData *cachedData = self.cachedData;
        if (cachedData) {
            completionHandler(self, cachedData, nil);
            return;
        }
    }
    
    self.status = AWSContentStatusTypeRunning;
    self.downloadCompletionHandler = completionHandler;
    self.downloadProgressBlock = progressBlock;
    
    AWSContentManager *contentManager = self.manager;
    
    __weak AWSContent *weakSelf = self;
    [contentManager.contentProvider GETURLForKey:self.key
                               completionHandler:^(NSURL *URL, NSError *error) {
                                   if ((!URL && !error) || (URL && error)) {
                                       @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                                                      reason:@"The content provider returned nil / values for both the URL and error. This should not happen."
                                                                    userInfo:nil];
                                   }
                                   if (error) {
                                       completionHandler(weakSelf, nil, error);
                                   }
                                   if (URL) {
                                       NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
                                       request.cachePolicy = NSURLRequestReloadIgnoringLocalCacheData;
                                       request.HTTPMethod = @"GET";
                                       [self setUserAgentForRequest:request];
                                       
                                       if (loadingType == AWSContentDownloadTypeIfNewerExists) {
                                           NSData *cachedData = weakSelf.cachedData;
                                           if (cachedData) {
                                               [request setValue:[cachedData aws_md5String] forHTTPHeaderField:@"If-None-Match"];
                                           }
                                       }
                                       
                                       NSURLSessionDownloadTask *downloadTask = [contentManager.URLSession downloadTaskWithRequest:request];
                                       
                                       contentManager.runningTasks[@(downloadTask.taskIdentifier)] = weakSelf;
                                       weakSelf.pinOnCompletion = pinOnCompletion;
                                       
                                       [downloadTask resume];
                                   }
                               }];
}

- (void)getRemoteFileURLWithCompletionHandler:(void(^)(NSURL  * _Nullable url, NSError  * _Nullable error))completionHandler {
    if (self.isDirectory) {
        NSError *error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                             code:AWSContentManagerErrorTypeDirectoryCannotBeDownloaded
                                         userInfo:nil];
        completionHandler(nil, error);
        return;
    }
    
    AWSContentManager *contentManager = self.manager;
    
    [contentManager.contentProvider GETURLForKey:self.key
                               completionHandler:^(NSURL *URL, NSError *error) {
                                   dispatch_async(dispatch_get_main_queue(), ^{
                                       if ((!URL && !error) || (URL && error)) {
                                           @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                                                          reason:@"The content provider returned nil / values for both the URL and error. This should not happen."
                                                                        userInfo:nil];
                                       }
                                       completionHandler(URL, error);
                                   });
                               }];
}

- (NSData *)cachedData {
    AWSContentManager *contentManager = self.manager;
    AWSTMCache *contentCache = contentManager.contentCache;
    
    id object = [contentCache objectForKey:self.key];
    if (!object) {
        AWSTMCache *pinnedCache = contentManager.pinnedCache;
        object = [pinnedCache objectForKey:self.key];
    }
    
    return object;
}

- (void)pin {
    AWSContentManager *contentManager = self.manager;
    AWSTMCache *contentCache = contentManager.contentCache;
    AWSTMCache *pinnedCache = contentManager.pinnedCache;
    
    id object = [contentCache objectForKey:self.key];
    [pinnedCache.diskCache setObject:object
                              forKey:self.key];
    [contentCache removeObjectForKey:self.key];
}

- (void)unPin {
    AWSContentManager *contentManager = self.manager;
    AWSTMCache *contentCache = contentManager.contentCache;
    AWSTMCache *pinnedCache = contentManager.pinnedCache;
    
    id object = [pinnedCache objectForKey:self.key];
    [contentCache.diskCache setObject:object
                               forKey:self.key];
    [pinnedCache removeObjectForKey:self.key];
}

- (void)removeLocal {
    AWSContentManager *contentManager = self.manager;
    AWSTMCache *contentCache = contentManager.contentCache;
    AWSTMCache *pinnedCache = contentManager.pinnedCache;
    
    [contentCache removeObjectForKey:self.key];
    [pinnedCache removeObjectForKey:self.key];
}

- (void)removeRemoteContentWithCompletionHandler:(void(^)(AWSContent *content, NSError *error))completionHandler {
    if (self.status == AWSContentStatusTypeRunning) {
        NSError *error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                             code:AWSContentManagerErrorTypeTransferAlreadyInProgress
                                         userInfo:nil];
        completionHandler(self, error);
        return;
    }
    
    self.status = AWSContentStatusTypeRunning;
    
    AWSContentManager *contentManager = self.manager;
    
    __weak AWSContent *weakSelf = self;
    [contentManager.contentProvider
     DELETEURLForKey:self.key
     completionHandler:^(NSURL *URL, NSError *error) {
         if (!URL && !error) {
             @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                            reason:@"The content provider returned nil for the URL and error. This should not happen."
                                          userInfo:nil];
         }
         if (error) {
             completionHandler(weakSelf, error);
         }
         if (URL) {
             NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
             request.cachePolicy = NSURLRequestReloadIgnoringLocalCacheData;
             request.HTTPMethod = @"DELETE";
             [self setUserAgentForRequest:request];
             
             NSURLSessionDataTask *downloadTask =
             [contentManager.URLSession
              dataTaskWithRequest:request
              completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                  dispatch_async(dispatch_get_main_queue(), ^{
                      NSHTTPURLResponse *HTTPResponse = (NSHTTPURLResponse *)response;
                      if (HTTPResponse.statusCode / 100 == 4) {
                          AWSLogError(@"Transfer failed. HTTP Status Code: %lld", (long long)HTTPResponse.statusCode);
                          NSError *clientError = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                                                     code:AWSContentManagerErrorTypeClientException
                                                                 userInfo:nil];
                          completionHandler(weakSelf, clientError);
                      } else if (HTTPResponse.statusCode / 100 == 5) {
                          AWSLogError(@"Transfer failed. HTTP Status Code: %lld", (long long)HTTPResponse.statusCode);
                          NSError *clientError = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                                                     code:AWSContentManagerErrorTypeServiceException
                                                                 userInfo:nil];
                          completionHandler(weakSelf, clientError);
                      } else {
                          completionHandler(weakSelf, error);
                      }
                  });
              }];
             [downloadTask resume];
         }
     }];
}

#pragma mark - Utility methods

- (void)setUserAgentForRequest:(NSMutableURLRequest *)request {
    [request setValue:[AWSServiceConfiguration baseUserAgent] forHTTPHeaderField:@"User-Agent"];
}

@end

@implementation AWSLocalContent

- (instancetype)initWithManager:(AWSContentManager *)manager
                           data:(NSData *)data
                            key:(NSString *)key {
    if (self = [super initWithManager:manager]) {
        self.key = key;
        self.uploadData = data;
    }
    return self;
}

- (void)uploadWithPinOnCompletion:(BOOL)pinOnCompletion
                    progressBlock:(void(^)(AWSLocalContent *content, NSProgress *progress))progressBlock
                completionHandler:(void(^)(AWSLocalContent *content, NSError *error))completionHandler {
    if (self.isDirectory) {
        NSError *error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                             code:AWSContentManagerErrorTypeDirectoryCannotBeDownloaded
                                         userInfo:nil];
        completionHandler(self, error);
        return;
    }
    if (self.status == AWSContentStatusTypeRunning) {
        NSError *error = [NSError errorWithDomain:AWSContentManagerErrorDomain
                                             code:AWSContentManagerErrorTypeTransferAlreadyInProgress
                                         userInfo:nil];
        completionHandler(self, error);
        return;
    }
    
    self.status = AWSContentStatusTypeRunning;
    self.uploadCompletionHandler = completionHandler;
    self.uploadProgressBlock = progressBlock;
    
    AWSContentManager *contentManager = self.manager;
    
    __weak AWSLocalContent *weakSelf = self;
    [contentManager.contentProvider PUTURLForKey:self.key
                               completionHandler:^(NSURL *URL, NSError *error) {
                                   if (!URL && !error) {
                                       @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                                                      reason:@"The content provider returned nil for the URL and error. This should not happen."
                                                                    userInfo:nil];
                                   }
                                   if (error) {
                                       completionHandler(weakSelf, error);
                                   }
                                   if (URL) {
                                       NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
                                       request.cachePolicy = NSURLRequestReloadIgnoringLocalCacheData;
                                       request.HTTPMethod = @"PUT";
                                       request.HTTPBody = self.uploadData;
                                       [self setUserAgentForRequest:request];
                                       
                                       // In order to send an empty HTTP body (for creating a directory in S3), you need to use NSURLSessionDataTask.
                                       // If you need to switch it to NSURLSessionUploadTask, you need to have a separate case for creating a directory.
                                       NSURLSessionDataTask *uploadTask = [contentManager.URLSession dataTaskWithRequest:request];
                                       
                                       contentManager.runningTasks[@(uploadTask.taskIdentifier)] = weakSelf;
                                       weakSelf.pinOnCompletion = pinOnCompletion;
                                       [contentManager.uploadingContents addObject:weakSelf];
                                       
                                       [uploadTask resume];
                                   }
                               }];
}

@end

#pragma mark - AWSS3ContentProvider

@implementation AWSS3ContentProvider

- (instancetype)init {
    assert(false);
}

- (instancetype)initWithBucket:(NSString *)bucket {
    if (self = [super init]) {
        _bucket = bucket;
        _serviceConfiguration = AWSServiceManager.defaultServiceManager.defaultServiceConfiguration;
    }
    
    return self;
}

- (instancetype)initWithBucket:(NSString *)bucket
          serviceConfiguration:(AWSServiceConfiguration *)serviceConfiguration {
    if (self = [super init]) {
        _bucket = bucket;
        _serviceConfiguration = serviceConfiguration;
        if(_serviceConfiguration == AWSServiceManager.defaultServiceManager.defaultServiceConfiguration) {
            _awsS3PresignedURLBuilder = [AWSS3PreSignedURLBuilder defaultS3PreSignedURLBuilder];
        } else {
            [AWSS3PreSignedURLBuilder registerS3PreSignedURLBuilderWithConfiguration:self.serviceConfiguration
                                                                              forKey:self.bucket];
            _awsS3PresignedURLBuilder = [AWSS3PreSignedURLBuilder S3PreSignedURLBuilderForKey:self.bucket];
        }
    }
    
    return self;
}

- (void)GETURLForKey:(NSString *)key
   completionHandler:(void (^)(NSURL *, NSError *))completionHandler {
    AWSS3PreSignedURLBuilder *s3PreSignedURLBuilder = self.awsS3PresignedURLBuilder;
    AWSS3GetPreSignedURLRequest *getPreSignedURLRequest = [AWSS3GetPreSignedURLRequest new];
    getPreSignedURLRequest.bucket = self.bucket;
    getPreSignedURLRequest.key = key;
    getPreSignedURLRequest.HTTPMethod = AWSHTTPMethodGET;
    getPreSignedURLRequest.expires = [NSDate dateWithTimeIntervalSinceNow:50 * 60]; // 50 minutes
    [[s3PreSignedURLBuilder getPreSignedURL:getPreSignedURLRequest] continueWithBlock:^id(AWSTask *task) {
        if (task.error) {
            NSError *error = task.error;
            completionHandler(nil, error);
        }
        if (task.result) {
            NSURL *URL = task.result;
            completionHandler(URL, nil);
        }
        return nil;
    }];
}

- (void)PUTURLForKey:(NSString *)key
   completionHandler:(void(^)(NSURL *URL, NSError *error))completionHandler {
    AWSS3PreSignedURLBuilder *s3PreSignedURLBuilder = self.awsS3PresignedURLBuilder;
    AWSS3GetPreSignedURLRequest *getPreSignedURLRequest = [AWSS3GetPreSignedURLRequest new];
    getPreSignedURLRequest.bucket = self.bucket;
    getPreSignedURLRequest.key = key;
    getPreSignedURLRequest.HTTPMethod = AWSHTTPMethodPUT;
    getPreSignedURLRequest.expires = [NSDate dateWithTimeIntervalSinceNow:50 * 60]; // 50 minutes
    [[s3PreSignedURLBuilder getPreSignedURL:getPreSignedURLRequest] continueWithExecutor:[AWSExecutor mainThreadExecutor] withBlock:^id(AWSTask *task) {
        if (task.error) {
            NSError *error = task.error;
            completionHandler(nil, error);
        }
        if (task.result) {
            NSURL *URL = task.result;
            completionHandler(URL, nil);
        }
        return nil;
    }];
}

- (void)DELETEURLForKey:(NSString *)key
      completionHandler:(void (^)(NSURL *, NSError *))completionHandler {
    AWSS3PreSignedURLBuilder *s3PreSignedURLBuilder = self.awsS3PresignedURLBuilder;
    AWSS3GetPreSignedURLRequest *getPreSignedURLRequest = [AWSS3GetPreSignedURLRequest new];
    getPreSignedURLRequest.bucket = self.bucket;
    getPreSignedURLRequest.key = key;
    getPreSignedURLRequest.HTTPMethod = AWSHTTPMethodDELETE;
    getPreSignedURLRequest.expires = [NSDate dateWithTimeIntervalSinceNow:50 * 60]; // 50 minutes
    [[s3PreSignedURLBuilder getPreSignedURL:getPreSignedURLRequest] continueWithBlock:^id(AWSTask *task) {
        if (task.error) {
            NSError *error = task.error;
            completionHandler(nil, error);
        }
        if (task.result) {
            NSURL *URL = task.result;
            completionHandler(URL, nil);
        }
        return nil;
    }];
}

@end

#pragma mark - AWSCloudFrontContentProvider

@implementation AWSCloudFrontContentProvider

- (instancetype)init {
    assert(false);
}

- (instancetype)initWithCloudFrontURL:(NSString *)cloudFrontURL {
    if (self = [super init]) {
        _cloudFrontURL = cloudFrontURL;
    }
    
    return self;
}

- (void)GETURLForKey:(NSString *)key
   completionHandler:(void (^)(NSURL *, NSError *))completionHandler {
    NSString *completeUrl =[NSString stringWithFormat:@"%@/%@",self.cloudFrontURL,key];
    NSURL *URL =[NSURL URLWithString: [completeUrl stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]]];
    completionHandler(URL, nil);
}

- (void)PUTURLForKey:(NSString *)key
   completionHandler:(void(^)(NSURL *URL, NSError *error))completionHandler {
    // Not supported.
}

- (void)DELETEURLForKey:(NSString *)key
      completionHandler:(void (^)(NSURL *, NSError *))completionHandler {
    // Not supported.
}

@end

#pragma mark - Utility methods

@implementation NSURL (AWS)

- (id)aws_getResourceValue:(NSString *)key {
    NSError *error = nil;
    id objectToRetrieve = nil;
    BOOL result = [self getResourceValue:&objectToRetrieve
                                  forKey:key
                                   error:&error];
    if (!result) {
        AWSLogError(@"Failed to get a resource value for the file URL: %@", error);
    }
    
    return objectToRetrieve;
}

@end

@implementation NSData (AWS)

- (NSString *)aws_md5String {
    unsigned char digestArray[CC_MD5_DIGEST_LENGTH];
    CC_MD5([self bytes], (CC_LONG)[self length], digestArray);
    
    NSMutableString *md5String = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2];
    for (int i = 0; i < CC_MD5_DIGEST_LENGTH; i++) {
        [md5String appendFormat:@"%02x", digestArray[i]];
    }
    return md5String;
}

@end

@interface AWSTMDiskCache ()

@property (assign, nonatomic) dispatch_queue_t queue;

- (NSURL *)encodedFileURLForKey:(NSString *)key;

@end

@implementation AWSTMDiskCache (AWS)

- (NSURL *)aws_fileURLWithoutUpdatingLastAccessedDateForKey:(NSString *)key
{
    if (!key)
        return nil;
    
    __block NSURL *fileURLForKey = nil;
    
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    
    [self aws_fileURLWithoutUpdatingLastAccessedDateForKey:key block:^(AWSTMDiskCache *cache, NSString *key, id <NSCoding> object, NSURL *fileURL) {
        fileURLForKey = fileURL;
        dispatch_semaphore_signal(semaphore);
    }];
    
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    
#if !OS_OBJECT_USE_OBJC
    dispatch_release(semaphore);
#endif
    
    return fileURLForKey;
}

- (void)aws_fileURLWithoutUpdatingLastAccessedDateForKey:(NSString *)key block:(AWSTMDiskCacheObjectBlock)block
{
    if (!key || !block)
        return;
    
    __weak AWSTMDiskCache *weakSelf = self;
    
    dispatch_async(self.queue, ^{
        AWSTMDiskCache *strongSelf = weakSelf;
        if (!strongSelf)
            return;
        
        NSURL *fileURL = [strongSelf encodedFileURLForKey:key];
        
        if (![[NSFileManager defaultManager] fileExistsAtPath:[fileURL path]]) {
            fileURL = nil;
        }
        
        block(strongSelf, key, nil, fileURL);
    });
}

@end

#pragma mark - AWSContentManagerConfiguration

@implementation AWSContentManagerConfiguration

@synthesize serviceConfiguration = _serviceConfiguration;

- (instancetype)initWithBucketName:(NSString *)bucketName
                     cloudFrontURL:(NSString * _Nullable)cloudFrontURL
              serviceConfiguration:(AWSServiceConfiguration *)serviceConfiguration {
    if (self = [super init]) {
        _bucketName = bucketName;
        _cloudFrontURL = cloudFrontURL;
        _serviceConfiguration = serviceConfiguration;
    }
    return self;
}

- (instancetype)initWithBucketName:(NSString *)bucketName {
    return [[AWSContentManagerConfiguration alloc] initWithBucketName:bucketName
                                                        cloudFrontURL:nil
                                                 serviceConfiguration:nil];
}

- (instancetype)initWithBucketName:(NSString *)bucketName
                     cloudFrontURL:(NSString *)cloudFrontURL {
    return [[AWSContentManagerConfiguration alloc] initWithBucketName:bucketName
                                                        cloudFrontURL:cloudFrontURL
                                                 serviceConfiguration:nil];
}

- (AWSServiceConfiguration *)serviceConfiguration {
    if (!_serviceConfiguration) {
        return AWSServiceManager.defaultServiceManager.defaultServiceConfiguration;
    }
    
    return _serviceConfiguration;
}

@end
